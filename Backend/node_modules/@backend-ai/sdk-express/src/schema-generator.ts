import { GoogleGenerativeAI } from '@google/generative-ai';
import { DiscoveredRoute, ToolDefinition } from './types';

/**
 * Schema Generator using Gemini AI
 * Analyzes route handlers and generates semantic schemas
 */
export class SchemaGenerator {
    private genAI: GoogleGenerativeAI | null = null;
    private model: any = null;
    private toolCache: Map<string, ToolDefinition> = new Map();
    private verbose: boolean;

    constructor(apiKey?: string, modelName: string = 'gemini-2.5-flash', verbose: boolean = false) {
        this.verbose = verbose;

        // Try apiKey parameter first, then environment variable
        const key = apiKey || process.env.GEMINI_API_KEY;

        if (!key) {
            console.warn('⚠️ GEMINI_API_KEY not set. Using fallback metadata generation.');
            return;
        }

        try {
            this.genAI = new GoogleGenerativeAI(key);
            this.model = this.genAI.getGenerativeModel({ model: modelName });

            if (this.verbose) {
                console.log(`✅ Initialized Gemini model: ${modelName}`);
            }
        } catch (error) {
            console.error('❌ Failed to initialize Gemini:', error);
        }
    }

    /**
     * Generate tool definitions for all routes
     */
    async generateSchemas(routes: DiscoveredRoute[]): Promise<ToolDefinition[]> {
        const tools: ToolDefinition[] = [];

        for (const route of routes) {
            try {
                // Add a small delay to prevent rate limiting
                await new Promise(resolve => setTimeout(resolve, 500));

                const tool = await this.generateToolDefinition(route);
                tools.push(tool);

                if (this.verbose) {
                    console.log(`✅ Generated schema for ${route.method} ${route.path}`);
                }
            } catch (error) {
                console.error(`❌ Failed to generate schema for ${route.method} ${route.path}:`, error);
            }
        }

        return tools;
    }

    /**
     * Generate tool definition for a single route
     */
    async generateToolDefinition(route: DiscoveredRoute): Promise<ToolDefinition> {
        const cacheKey = `${route.method}:${route.path}`;

        if (this.toolCache.has(cacheKey)) {
            return this.toolCache.get(cacheKey)!;
        }

        // Extract path parameters
        const { pathParams, requiredPathParams } = this.extractPathParams(route.path);

        // Generate semantic metadata using AI
        const { name, description } = await this.generateSemanticMeta(route);

        // Generate input schema using AI
        const bodySchema = await this.generateInputSchema(route);

        // Merge path params with body params
        const inputSchema = {
            type: 'object' as const,
            description: `Input parameters for ${route.path}`,
            properties: {
                ...pathParams,
                ...(bodySchema.properties || {}),
            },
            required: [
                ...requiredPathParams,
                ...(bodySchema.required || []),
            ],
        };

        // Enrich properties with better descriptions
        const enrichedProperties = this.enrichProperties(inputSchema.properties);

        // Create tool definition
        const tool: ToolDefinition = {
            tool_id: this.generateToolId(route),
            name,
            description,
            input_schema: {
                type: 'object',
                description: inputSchema.description,
                properties: enrichedProperties,
                required: inputSchema.required,
            },
            response_schema: {
                type: 'object',
                description: `Response returned by ${name}`,
                properties: {},
            },
            adapter: {
                framework: 'express',
                method: route.method,
                path: route.path,
            },
        };

        this.toolCache.set(cacheKey, tool);
        return tool;
    }

    /**
     * Extract path parameters from route path
     */
    private extractPathParams(path: string): {
        pathParams: Record<string, any>;
        requiredPathParams: string[];
    } {
        const pathParams: Record<string, any> = {};
        const requiredPathParams: string[] = [];

        const pathParts = path.split('/');

        for (const part of pathParts) {
            if (part.startsWith(':')) {
                const isOptional = part.endsWith('?');
                const key = part.substring(1, part.length + (isOptional ? -1 : 0));

                pathParams[key] = {
                    type: 'string',
                    description: `Path parameter: ${key}`,
                };

                if (!isOptional) {
                    requiredPathParams.push(key);
                }
            }
        }

        return { pathParams, requiredPathParams };
    }

    /**
     * Generate semantic name and description using AI
     */
    private async generateSemanticMeta(
        route: DiscoveredRoute
    ): Promise<{ name: string; description: string }> {
        if (!this.model) {
            return this.generateFallbackMeta(route);
        }

        try {
            const handlerCode = route.handler.toString();

            const prompt = `
You are generating human-readable tool metadata for an AI agent.

Based on this Express route handler, generate:
1. A SHORT tool name (2–4 words, business-focused)
2. A ONE-LINE business description (what the API does, not HTTP details)

Rules:
- Do NOT mention HTTP, POST, GET, routes, endpoints
- Focus on business intent
- Keep description clear and simple

Return ONLY valid JSON:
{
  "name": "...",
  "description": "..."
}

Handler code:
\`\`\`javascript
${handlerCode}
\`\`\`
`;

            const result = await this.model.generateContent(prompt);
            const cleaned = result.response
                .text()
                .replace(/```json\n?/g, '')
                .replace(/```\n?/g, '')
                .trim();

            const parsed = JSON.parse(cleaned);

            return {
                name: parsed.name,
                description: parsed.description,
            };
        } catch (error) {
            if (this.verbose) {
                console.warn(`⚠️ AI meta generation failed for ${route.method} ${route.path}, using fallback`);
            }
            return this.generateFallbackMeta(route);
        }
    }

    /**
     * Fallback metadata generation (when AI is not available)
     */
    private generateFallbackMeta(route: DiscoveredRoute): { name: string; description: string } {
        return {
            name: `${route.method} ${route.path}`,
            description: `Executes ${route.method} ${route.path} operation`,
        };
    }

    /**
     * Generate input schema using AI
     */
    private async generateInputSchema(route: DiscoveredRoute): Promise<any> {
        if (!this.model) {
            return { properties: {}, required: [] };
        }

        try {
            const handlerCode = route.handler.toString();

            const prompt = `
Analyze this Express.js route handler and generate a JSON schema for request body parameters.

Rules:
- Identify req.body usage
- Infer data types (string, number, boolean, object, array)
- Mark required fields
- Add short descriptions

Return ONLY valid JSON schema:
{
  "properties": {
    "fieldName": { "type": "string", "description": "..." }
  },
  "required": ["fieldName"]
}

Code:
\`\`\`javascript
${handlerCode}
\`\`\`
`;

            const result = await this.model.generateContent(prompt);
            const cleaned = result.response
                .text()
                .replace(/```json\n?/g, '')
                .replace(/```\n?/g, '')
                .trim();

            return JSON.parse(cleaned);
        } catch (error) {
            return { properties: {}, required: [] };
        }
    }

    /**
     * Enrich property descriptions
     */
    private enrichProperties(
        properties: Record<string, any>,
        parentName: string = ''
    ): Record<string, any> {
        const enriched: Record<string, any> = {};

        for (const [key, value] of Object.entries(properties)) {
            const type = value.type || 'string';

            if (type === 'object' && value.properties) {
                enriched[key] = {
                    type: 'object',
                    description: value.description || `${key} details`,
                    properties: this.enrichProperties(value.properties, key),
                };
            } else if (type === 'array' && value.items) {
                enriched[key] = {
                    type: 'array',
                    description: value.description || `List of ${key}`,
                    items:
                        value.items.type === 'object'
                            ? {
                                type: 'object',
                                properties: this.enrichProperties(value.items.properties || {}, key),
                            }
                            : value.items,
                };
            } else {
                enriched[key] = {
                    type,
                    description:
                        value.description ||
                        `${parentName ? parentName + ' ' : ''}${key}`.replace(/_/g, ' '),
                };
            }
        }

        return enriched;
    }

    /**
     * Generate tool ID from route
     */
    private generateToolId(route: DiscoveredRoute): string {
        return `express.${route.path
            .replace(/^\//, '')
            .replace(/\/:/g, '.')
            .replace(/\//g, '.')
            .replace(/:/g, '')}.${route.method.toLowerCase()}`;
    }

    /**
     * Clear cache
     */
    clearCache(): void {
        this.toolCache.clear();
    }
}
